{% extends "layout_fs.twig" %}

{% block title %}Le monde{% endblock title %}
       
{% block style %}

	    <link rel="stylesheet" href="{{ app.request.basepath }}/ol/ol.css" />
	    <link rel="stylesheet" href="{{ app.request.basepath }}/css/worldmap.css" />
        
		<style>		
		
		body {
 		   padding: 0;
    	   margin: 0;
		}
		html, body, #map {
    		height: 100vh;
    		width: 100vw;
		}


		</style>
{% endblock %}

{% block content %}
<div class="clearfix">
	<form class="form-inline">
      	<label>Action &nbsp;</label>
      	<select id="action_select">
       		<option value="none">Voir</option>
        	<option value="translate_label">Déplacer labels</option>
        	<option value="modify_label">Modifier labels</option>
      	</select>
    </form>
	<div class="mapbox">
		<div id="map"></div>
	</div> 		
</div>
{% endblock %}

{% block javascript %}

<script src="{{ app.request.basepath }}/ol/ol.js"></script>
<script src="{{ app.request.basepath }}/js/app/util.js"></script>
<script src="{{ app.request.basepath }}/js/app/mapconfig.js"></script>

<script>
var Carte = {
    olMap: null,
    maxResolution: null,

    createMap: function(mapName){
        var self = this;
        
        for (var i=0; i<Mapconfig.maps.length; i++) {
            if(Mapconfig.maps[i].name == mapName) {
                var config = Mapconfig.maps[i];
  
                var mapMaxX = Mapconfig.background.tilesX * Mapconfig.background.tileSize;
                var mapMaxY = Mapconfig.background.tilesY * Mapconfig.background.tileSize;
                var mapCenter = [mapMaxX / 2, mapMaxY / 2];//[1673, 7923]; //[4190, 9838];//[mapMaxX / 2, mapMaxY / 2];
                var lmproj = new ol.proj.Projection({
                    code: 'LMPROJ',
                    units: 'pixels',
                    extent: [0, 0, mapMaxX, mapMaxY]
                });

                self.maxResolution = mapMaxX / Mapconfig.background.tileSize;    // 16384 / 256 = 64
                var resolutions = [];
                for (var z = 0; z <= 6; z++) {
                    resolutions[z] = self.maxResolution / Math.pow(2, z); 					// 64, 32, 16, 8, 4, 2, 1 (7 niveaux)
                }

                this.olMap = new ol.Map({
                    target: 'map',
                    view: new ol.View({
                        projection: lmproj, 
                        zoom: 3, //config.maxZoom,
                        minZoom: config.minZoom,
                        maxZoom: config.maxZoom,
                        center: mapCenter, 
                        extent: lmproj.getExtent(),
                        enableRotation: false
                    })
                });

				// Ajout de la première couche = la plus au fond = la couche image vide
				// pour le moment on utilise toujours cette couche en fond mais je le mets dans un if pour plus tard au cas où
                if (config.useBackground) {
                    var backgroundLayer = new ol.layer.Tile({
                        source: new ol.source.TileImage({
                            tileUrlFunction: function(tileCoord, pixelRatio, projection) { 
                                var z = tileCoord[0];
                                var x = tileCoord[1];
                                var y = -tileCoord[2] - 1;
                                return '{{ app.request.basepath }}/' + Mapconfig.background.mapUrl +'/' + z + '/' + x + '/' + y + '.png';
                            },
                            projection: lmproj,
                            tileGrid: new ol.tilegrid.TileGrid({
                                origin: ol.extent.getTopLeft(lmproj.getExtent()),
                                resolutions: resolutions,
                                tileSize: Mapconfig.background.tileSize
                            }),
                        }),
                        extent: lmproj.getExtent()
                    }); 
                    this.olMap.addLayer(backgroundLayer);
                }
                
                // ensuite on crée une couche vecteur pour chaque type de données à afficher
                // dans l'ordre de la config (évite de devoir gérer un zIndex)
                $(config.layers).each(function(key, confLayer){
                    var lay = new ol.layer.Vector({
                        name: confLayer.layerName,
                        source: new ol.source.Vector({ features: new ol.Collection([]) })
                    });
                    self.olMap.addLayer(lay);
                    
                    // On crée le style par défaut pour les éléments de cette couche, tel que défini dans la config
                    // Le style dépend du type d'élément (toujours le même type pour une même couche)
                    var styleFunc = self.createStyleFunc(confLayer.geomType, confLayer.styles.zooms, confLayer.styles);
                    lay.setStyle(styleFunc);
                    
                    // Enfin, on crée les features
                    // ici aussi les opérations dépendent du type de géométrie de la couche                    
                    $.ajax({
                        dataType: "json",
                        url: confLayer.source,
                        success: function(data) {
                            $(data).each(function(key, obj) {
                                if (obj.geom != null)
                                {	
                                    var parsedGeom = JSON.parse(obj.geom);		
                                    
                                    switch (confLayer.geomType) {
                                        case "Polygon":
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
                                            });
                                            newFeature.territoireId = obj.id;
                                            break;
                                        case "Label":
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.Point(parsedGeom.coordinates)
                                            });
                                            newFeature.texte = obj.texte;
                                            newFeature.territoireId = obj.id;
                                            break;
                                        case "Point":
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.Point(parsedGeom.coordinates)
                                            });
                                            newFeature.src = obj.src;
                                            break;
                                        case "Line" :
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.LineString(parsedGeom.coordinates)
                                            });
                                            break;
                                        default:
                                            console.log("type de geometrie non traité");
                                            break;
                                    }
                                    Util.transform(newFeature.getGeometry(), 'EPSG:4326', 'LMPROJ');
                                    lay.getSource().addFeature(newFeature);
                                }
                        });
                    }
                    }).error(function() {
                        console.log("erreur chargement json");
                    });
                });
                break;
            }
        }
    },
    
	createStyleFunc : function(categ, zooms, props) { 
		// A faire : gestion d'erreurs
		var self = this;
		var styleFunc;
		
		 switch(categ){
            case "Label": 
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    if (zooms.indexOf(zoomLevel) == -1) { return null; } // si le zoom affiché n'est pas dans la liste des zooms de visibilité de la couche) on n'affiche rien                 
                    var found = props.zooms.indexOf(zoomLevel);
                                    
                    var txt = props.textTransformation === "toUpper" ? feat.texte.toUpperCase() : feat.texte; 
                    var lignes = txt.split('#');
                    var styles = [];
                    
                    if(found != -1) {                       
                        $(lignes).each(function(key, value) { 
                            if (key==0) {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize[found] +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) })
                                    })
                                }));
                            } else {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize[found] +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) })
                                    }),
                                    geometry: function(feature) {
                                            // on crée un point d'ancrage décalé de x pixels (dans la config) pour les lignes suivantes
                                            var coordinates = feature.getGeometry().getCoordinates();
                                            coordinates[1] = coordinates[1] - props.interligne *key;
                                            return new ol.geom.Point(coordinates);
                                        }
                                    }) 
                                );
                            }
                        });
                        if (lignes.length==1) { return styles[0]; } else { return styles; }
                    }
                    else return null;
                };
                break;
            case "Polygon":
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
 					if (zooms.indexOf(zoomLevel) == -1) { return null; }
                    var found = props.zooms.indexOf(zoomLevel);
                    if(found != -1) {
                    	// on peut afficher soir le contour, soit l'intérieur, soit les deux
                    	var leStyle = new ol.style.Style();                   	
                    	if (props.fillColor !== undefined) { 
                    		leStyle.setFill(new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) })); 
                    	}
                    	if (props.strokeColor !== undefined) {
                    		leStyle.setStroke (new ol.style.Stroke ({ 
                                color: Util.hexToRgba(props.strokeColor, props.strokeOpacity),
                                width: props.strokeWidth[found] }));
                    	}
                    	return leStyle;
                    } 
                    else return null;
                };
                break;
            case "Point":
                styleFunc = function(feat, reso) {
                    var zoomLevel = Math.log2(self.maxResolution / reso);
					if (zooms.indexOf(zoomLevel) == -1) { return null; }
                    var found = props.zooms.indexOf(zoomLevel);
                    if(found != -1) {
                        // on regarde quel type d'image on a
                        var imgStyle = null; console.log(feat.src);
                        switch (feat.src) {
                            case 'cercle' :
                                imgStyle = new ol.style.Circle({
                                    radius : props.pointRadius[found],
                                    fill : new ol.style.Fill ({color: Util.hexToRgba(props.fillColor, props.fillOpacity) })
                                });
                            break;
                            default :
                                imgStyle = new ol.style.Icon({
                                    size: [props.imgHeight[found], props.imgWidth[found]],
                                    src: '{{ app.request.basepath }}/' + feat.src
                                });
                        }
                        return new ol.style.Style ({
                            image: imgStyle
                        });
                    } 
                    else return null;
                };
                break;
            case "Line":
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    if (zooms.indexOf(zoomLevel) == -1) { return null; }
                    var found = props.zooms.indexOf(zoomLevel);
                    if(found != -1) {
                        return new ol.style.Style ({
                            stroke: new ol.style.Stroke ({ 
                                color: Util.hexToRgba(props.strokeColor, props.strokeOpacity),
                                width: props.strokeWidth[found], 
                                lineDash: props.strokeDashArray[found],
                                lineCap : props.strokeCap 
                            })
                        });
                    } 
                    else return null;
                }; 
                break;
            default:
                console.log("erreur, type de géométrie non géré");
        } 
        return styleFunc;	
	},
    
    initModifyFiefsInteraction: function(save) { //NE FONNCTIONNE PAS
        var self = this;
        // pour Basemap, les layers sont les suivantes :
        // 0: Background image
        // 1: noms de pays => Point => Translate
        // 2: frontières fiefs => Polygon => Modify        
        // 3: frontières pays => Polygon => pas d'interaction pour le moment (calculé)
        // 4: noms de fiefs => Point => Translate
                
        var modify = new ol.interaction.Modify({
            features: self.olMap.getLayers().getArray()[1].getSource().getFeaturesCollection(),
            // the SHIFT key must be pressed to delete vertices, so
            // that new vertices can be drawn at the same position
            // of existing vertices
            deleteCondition: function(event) {
            return ol.events.condition.shiftKeyOnly(event) &&
                ol.events.condition.singleClick(event);
            }
        });
        self.olMap.addInteraction(modify);
    },
    
    initTranslateLabelsTerritoiresInteractions : function (save) { //FONCTIONNE
        var self = this;
        var translate = new ol.interaction.Translate({ // Layer 1 pour les noms de pays, 4 pour les noms de fiefs ======> à rendre paramétrable
                layers: [
                    self.olMap.getLayers().getArray()[1],
                    self.olMap.getLayers().getArray()[4]
                ],
                hitTolerance: 5
        });
        
        if(save) {
            translate.on('translateend', function (e) { 
                // l'event translateend est appelé avant que la feature d'origine soit mise à jour avec les nouvelles coordonnées
                // on affecte donc les nouvelles coordonnées nnnous-mêmes à une géométrie qui ne sert que pour la sauvegarde
                var newGeom = e.features.getArray()[0].getGeometry().clone();
                newGeom.setCoordinates(e.coordinate);
                Util.transform(newGeom, 'LMPROJ', 'EPSG:4326');
                var convert = new ol.format.GeoJSON;
                var geojson = convert.writeGeometry(newGeom);
                
                $.ajax({
                    type: "POST",
                    dataType: 'json',
                    url: "worldmap/labelterritoire/"+e.features.getArray()[0].territoireId+"/update",
                    data: {geom: geojson},
                    success: function(data) {
                        // alert("la geographie a été enregistrée");
                        // a priori rien de spécial à faire pour l'instant!
                    }
                }).error(function() {
                    alert("désolé, une erreur est survenue");
                });
            }, this);
        }
        self.olMap.addInteraction(translate);
    },
    /*
    showCountriesColors : function (show) { // affichage des pays en couleur transparente comme sur la prod, pour voir le rendu uniquement ---- juste pour mon dev ----
        
        if (show) {
            var lay = new ol.layer.Vector({
                name: "surcouche",
                source: new ol.source.Vector({ features: new ol.Collection([]) })
            });
            this.olMap.addLayer(lay);
            
            $.ajax({
                dataType: "json",
                url: "world/countriesjson",
                success: function(data) {
                    $(data).each(function(key, obj) {
                        if (obj.geom != null)
                        {	
                            var parsedGeom = JSON.parse(obj.geom);		
                            $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
                                Util.LonLatToLM(coords);
                            });
                            var newFeature = new ol.Feature({
                                geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
                            });
                            var style = new ol.style.Style({
                                fill: new ol.style.Fill({ color: Util.hexToRgba(obj.color, 0.2) })
                            });
                            newFeature.setStyle(style);
                            lay.getSource().addFeature(newFeature);
                        }
                });
            }
            }).error(function() {
                console.log("erreur chargement json");
            });
            
        }
    },
*/
    initDrawLine : function() {
        var feats = new ol.Collection();
        var drawLine = new ol.interaction.Draw({ 
                features: feats,
                type: "LineString" 
        });  
        this.olMap.addInteraction(drawLine);
        drawLine.on('drawend', function(e) {
            //console.log(e.feature.getGeometry());
            var newLine = e.feature.getGeometry().clone();
            Util.transform(newLine, 'LMPROJ', 'EPSG:4326');
            var convert = new ol.format.GeoJSON;
            var geojson = convert.writeGeometry(newLine);

            var str = "INSERT INTO geo_surf (`type`, geojson) VALUES ('caravane', '" + geojson +"');" ; 
            console.log(str);
        });

    }      
};

    
var actionSelect = document.getElementById('action_select');
actionSelect.onchange = function() {
	//map.removeInteraction(draw);
	//addInteraction();
};


Carte.createMap("baseMap");
Carte.showCountriesColors(true); // pour afficher la surcouche des pays en couleur





//Carte.initModifyFiefsInteraction(false);
//Carte.initTranslateLabelsTerritoiresInteractions(true);
//Carte.initDrawLine();

// Cette fonctione me sers uniquement pour le dev, pour créer des objets sans avoir à créer les routes, etc...
Carte.olMap.on('click', function(e) { 
    var newPoint = new ol.geom.Point(e.coordinate);
    Util.transform(newPoint, 'LMPROJ', 'EPSG:4326');
    var convert = new ol.format.GeoJSON;
    var geojson = convert.writeGeometry(newPoint);
    
//    var str = "INSERT INTO geo_picto (`type`, geojson, url, rotation) VALUES ('exploration', '" + geojson +"', 'img/pictos/exploration.svg', 0);";
  var str = "INSERT INTO geo_picto (`type`, geojson, url, rotation) VALUES ('ville', '" + geojson +"', 'cercle', 0);" ;

    console.log(str);
});


</script>

{% endblock %}
