{% extends "layout_fs.twig" %}

{% block title %}Le monde{% endblock title %}
       
{% block style %}

	    <link rel="stylesheet" href="{{ app.request.basepath }}/ol/ol.css" />
	    <link rel="stylesheet" href="{{ app.request.basepath }}/css/worldmap.css" />
        
		<style>		
		
		body {
 		   padding: 0;
    	   margin: 0;
		}
		html, body, #map {
    		height: 100vh;
    		width: 100vw;
		}


		</style>
{% endblock %}

{% block content %}
<div class="clearfix">
	<div class="mapbox">
		<div id="map"></div>
	</div> 		
</div>
{% endblock %}

{% block javascript %}

<script src="{{ app.request.basepath }}/ol/ol.js"></script>
<script src="{{ app.request.basepath }}/js/app/util.js"></script>
<script src="{{ app.request.basepath }}/js/app/mapconfig.js"></script>

<script>
var Carte = {
    olMap: null,
    maxResolution: null,

    createMap: function(mapName){
        var self = this;
        
        for (var i=0; i<Mapconfig.maps.length; i++) {
            if(Mapconfig.maps[i].name == mapName) {
                var config = Mapconfig.maps[i];
                
                if (config.useBackground) {  
                    // pour le moment c'est toujours le cas ; je mets dans un if au cas où on veuille changer plus tard
                    var mapMaxX = Mapconfig.background.tilesX * Mapconfig.background.tileSize;
                    var mapMaxY = Mapconfig.background.tilesY * Mapconfig.background.tileSize;
                    var mapCenter = [4190, 9838];//[mapMaxX / 2, mapMaxY / 2];
                    var lmproj = new ol.proj.Projection({
                        code: 'LMPROJ',
                        units: 'pixels',
                        extent: [0, 0, mapMaxX, mapMaxY]
                    });

                    self.maxResolution = mapMaxX / Mapconfig.background.tileSize;    // 16384 / 256 = 64
                    var resolutions = [];
                    for (var z = 0; z <= 6; z++) {
                        resolutions[z] = self.maxResolution / Math.pow(2, z); 					// 64, 32, 16, 8, 4, 2, 1 (7 niveaux)
                    }

                    var backgroundLayer = new ol.layer.Tile({
                        source: new ol.source.TileImage({
                            tileUrlFunction: function(tileCoord, pixelRatio, projection) { 
                                var z = tileCoord[0];
                                var x = tileCoord[1];
                                var y = -tileCoord[2] - 1;
                                return '{{ app.request.basepath }}/' + Mapconfig.background.mapUrl +'/' + z + '/' + x + '/' + y + '.png';
                            },
                            projection: lmproj,
                            tileGrid: new ol.tilegrid.TileGrid({
                                origin: ol.extent.getTopLeft(lmproj.getExtent()),
                                resolutions: resolutions,
                                tileSize: Mapconfig.background.tileSize
                            }),
                        }),
                        extent: lmproj.getExtent()
                    }); 
                    
                    this.olMap = new ol.Map({
                        target: 'map',
                        view: new ol.View({
                            projection: lmproj, 
                            zoom: config.maxZoom,
                            minZoom: config.minZoom,
                            maxZoom: config.maxZoom,
                            center: mapCenter, 
                            extent: lmproj.getExtent()
                        })
                    });
                    this.olMap.addLayer(backgroundLayer);
                }
                
                // ensuite on crée une couche vecteur pour chaque type de données à afficher
                // dans l'ordre de la config (évite de devoir gérer un zIndex)
                $(config.layers).each(function(key, confLayer){
                    var lay = new ol.layer.Vector({
                        name: confLayer.layerName,
                        source: new ol.source.Vector({ features: new ol.Collection([]) })
                    });
                    self.olMap.addLayer(lay);
                    
                    // On crée le style par défaut pour les éléments de cette couche, tel que défini dans la config
                    // Le style dépend du type d'élément (toujours le même type pour une même couche)
                    // et de la résolution (épaisseur des traits, des pictogrammes, des pointillés...)
                    // On doit donc utiliser une fonction de style, et non pas simplement un style ou tableau de styles
                    var styleFunc = null;
                    switch(confLayer.geomType){
                        case "Label": 
                            styleFunc = function(feat, reso){
                                var zoomLevel = Math.log2(self.maxResolution / reso);
                                var found = confLayer.styles.zooms.indexOf(zoomLevel);
                                if(found != -1) {
                                    return new ol.style.Style ({
                                        text: new ol.style.Text({ 
                                            font: confLayer.styles.text.font[found],
                                            text: confLayer.styles.text.transformation === "toUpper" ? feat.texte.toUpperCase() : feat.texte,
                                            stroke: new ol.style.Stroke ({ color: Util.hexToRgba(confLayer.styles.stroke.color, confLayer.styles.stroke.opacity), width: confLayer.styles.stroke.width[found]}),
                                            fill: new ol.style.Fill({ color: Util.hexToRgba(confLayer.styles.fill.color, confLayer.styles.fill.opacity) })
                                            })
                                        })
                                }
                                else return null;
                            };
                            break;
                        case "Polygon":
                            styleFunc = function(feat, reso){
                                var zoomLevel = Math.log2(self.maxResolution / reso);
                                var found = confLayer.styles.zooms.indexOf(zoomLevel);
                                if(found != -1) {
                                    return new ol.style.Style ({
                                        stroke: new ol.style.Stroke ({ 
                                            color: Util.hexToRgba(confLayer.styles.stroke.color, confLayer.styles.stroke.opacity),
                                            width: confLayer.styles.stroke.width[found] })
                                        });
                                } 
                                else return null;
                            };
                            break;
                        default:
                            console.log("erreur, type de géométrie non géré");
                    }
                    lay.setStyle(styleFunc);
                    
                    // Enfin, on crée les features
                    // ici aussi les opérations dépendent du type de géométrie de la couche
                    var coordsToLM = function(tab) {
                        if (Array.isArray(tab[0])) {
                            var tabXY = []
                            for (var p=0; p<tab.length; p++) {
                                tabXY.push(coordsToLM(tab[p]));
                            }
                            return tabXY;
                        } else {
                            return Util.LonLatToLM([tab[0], tab[1]]);
                        }
                    };
                    
                    $.ajax({
                        dataType: "json",
                        url: confLayer.source,
                        success: function(data) {
                            $(data).each(function(key, obj) {
                                if (obj.geom != null)
                                {	
                                    var parsedGeom = JSON.parse(obj.geom);		

                                    // pour l'instant on bidouille parce que notre fichier source n'est pas formaté correctement
                                    // il faudra créer des urls /world/totojson pour chaque type de source qu'on veut exploiter
                                    
                                    switch (confLayer.geomType) {
                                        case "Polygon":
                                            $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
                                                Util.LonLatToLM(coords);
                                            });
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
                                            });
                                            newFeature.territoireId = obj.id;
                                            break;
                                        case "Label":
                                            Util.LonLatToLM(parsedGeom.coordinates);
                                            /*
                                            var tmpGeom = new ol.geom.Polygon(parsedGeom.geometry.coordinates);
                                            var ext = tmpGeom.getExtent();
                                            var areaCenter = [ext[0]+((ext[2]-ext[0])/2), ext[1]+((ext[3]-ext[1])/2)];
                                            */
                                            var newFeature = new ol.Feature({
                                                geometry: new ol.geom.Point(parsedGeom.coordinates)
                                            });
                                            
                                            newFeature.texte = obj.texte;
                                            newFeature.territoireId = obj.id;
                                            break;
                                        default:
                                            console.log("type de geometrie non traité");
                                            break;
                                    }
                                    
                                    lay.getSource().addFeature(newFeature);
                                }
                        });
                    }
                    }).error(function() {
                        console.log("erreur chargement json");
                    });
                });
                break;
            }
        }
    },
    
    initInteractions: function() {
        var self = this;
        // dans un premier temps on gère uniquement la modification de ce qui existe déjà, on verra plus tard pour ajouter ce qui manque
        // 1 interaction pour modifier les tracés des fiefs (et uniquement des fiefs, les régions et pays sont calculés)
        // 1 interaction pour déplacer les labels des fiefs et pays (les labels des régions ne sont pas affichés)
        //console.log(self.olMap.getLayers().getArray()[1].getSource().getFeatures());
        
        var modify = new ol.interaction.Modify({
        features: self.olMap.getLayers().getArray()[2].getSource().getFeaturesCollection(),
        // the SHIFT key must be pressed to delete vertices, so
        // that new vertices can be drawn at the same position
        // of existing vertices
        deleteCondition: function(event) {
          return ol.events.condition.shiftKeyOnly(event) &&
              ol.events.condition.singleClick(event);
        }
      });
      self.olMap.addInteraction(modify);
        
    }
    
};

Carte.createMap("baseMap");
//Carte.initInteractions();

// A déplacer dans l'objet Carte
Carte.olMap.on('click', function(e) {
    console.log(e.coordinate);
});


</script>

{% endblock %}
