{% extends "layout_fs.twig" %}

{% block title %}{{ geomap.nom }}{% endblock title %}
       
{% block style %}

	    <link rel="stylesheet" href="{{ app.request.basepath }}/ol/ol.css" />
	    <link rel="stylesheet" href="{{ app.request.basepath }}/css/carte.css" />
	
{% endblock %}

{% block content %}
<div class="clearfix">
	<div class="mapbox">
		<div id="map"></div>
	</div> 		
</div>
{% endblock %}

{% block javascript %}

<script src="{{ app.request.basepath }}/ol/ol.js"></script>
<script src="{{ app.request.basepath }}/js/carte_util.js"></script>

<script>
var geomapId = {{ geomap.id }}; 
var configSrc = '/mapmanager/config/get';
var featuresSrc = '/mapmanager/features';



var Carte = {
    olMap: null,			// l'objet map openLayers
    maxResolution: null,	// initialisé dans createMap
    resolutions: null, 		// initialisé dans createMap ; tableau des résolutions de la map (<=> aux différents niveaux de zoom) 
    config: null,			// la config de la carte récupérée dans la bdd, base de construction de la carte ol.Map
    projection: null, 		// initialisé dans createMap; la projection spécifique "à plat" utilisée n'est pas standard et doit être définie pour openLayers
    
    initMap: function(mapId) { 
    	var self = this;	
    	$.ajax({
            dataType: "json",
            url: configSrc + '/' + geomapId,
            success: function(data) {
            	self.config = data;
            	self.loadBackgroundLayer();
            	self.loadVectorLayers();    
        	}
        }).error(function() {
            console.log("erreur de lecture de la config, impossible de générer la carte");
        });
    },

    createMap: function(){
        var self = this;
        
        var mapMaxX = 16384; // taille du background image
        var mapMaxY = 11264; // à rendre paramétrable par la suite si d'autrtes fonds image sont utilisés
        var mapCenter = [mapMaxX / 2, mapMaxY / 2];
        self.projection = new ol.proj.Projection({
            code: 'LMPROJ',
            units: 'pixels',
            extent: [0, 0, mapMaxX, mapMaxY]
        });

        self.maxResolution = mapMaxX / 256;    // 16384 / 256 = 64
        self.resolutions = [];
        for (var z = 0; z <= 6; z++) {
            self.resolutions[z] = self.maxResolution / Math.pow(2, z); 					// 64, 32, 16, 8, 4, 2, 1 (7 niveaux)
        }

        this.olMap = new ol.Map({
            target: 'map',
            view: new ol.View({
                projection: self.projection, 
                zoom: 3, 	// à rendre paramétrable?
                minZoom: {{ geomap.zmin }},
                maxZoom: {{ geomap.zmax }},
                center: mapCenter, 
                extent: self.projection.getExtent(),
                enableRotation: false
            })
        });
    },
    
    loadBackgroundLayer: function () {
	    var backgroundLayer = new ol.layer.Tile({
		    source: new ol.source.TileImage({
		        tileUrlFunction: function(tileCoord, pixelRatio, projection) { 
		            var z = tileCoord[0];
		            var x = tileCoord[1];
		            var y = -tileCoord[2] - 1;
		            return '{{ app.request.basepath }}/img/map_clean/' + z + '/' + x + '/' + y + '.png';
		        },
		        projection: this.projection,
		        tileGrid: new ol.tilegrid.TileGrid({
		            origin: ol.extent.getTopLeft(this.projection.getExtent()),
		            resolutions: this.resolutions,
		            tileSize: 256
		        }),
		    }),
		    extent: this.projection.getExtent()
        }); 
        this.olMap.addLayer(backgroundLayer);   
    },
    
    loadVectorLayers: function () {
    	var self = this;

    	// on crée une couche vecteur pour chaque layer dans la config 
        $(self.config.layers).each(function(key, confLayer){
            var lay = new ol.layer.Vector({
                name: confLayer.categ,
                source: new ol.source.Vector({ features: new ol.Collection([]) })
            });
            lay.setProperties({	'geomType' : confLayer.geomtype });
            self.olMap.addLayer(lay);
                       
            // On crée le style par défaut pour les éléments de cette couche, tel que défini dans la config
            // Le style dépend du type d'élément (toujours le même type pour une même couche)
            var styleFunc = self.createStyleFunc(confLayer);
            lay.setStyle(styleFunc);
                       
            // Enfin, on crée les features
            // ici aussi les opérations dépendent du type de géométrie de la couche                    
            $.ajax({
                dataType: "json",
                url: featuresSrc + '/get/' + confLayer.categ,
                success: function(data) { 
                    $(data).each(function(key, obj) { 
                        if (obj.geojson != null)
                        {	
                            var parsedGeom = JSON.parse(obj.geojson);		
							var newFeature, geom;

                            switch (confLayer.geomtype) {
                                case "Surface": 
                                	geom = new ol.geom.Polygon(parsedGeom.coordinates);
                                    break;
                                case "Label":
                                case "Picto":
                                	geom = new ol.geom.Point(parsedGeom.coordinates);
                                    break;
                                case "LineString" :
                                	geom = new ol.geom.LineString(parsedGeom.coordinates);
                                    break;
                                default:
                                    console.log("type de geometrie non traité");
                                    break;
                            }
                            newFeature = new ol.Feature({ geometry: geom });
                            
							newFeature.bddId = obj.id;					
							if (obj.properties != null) {
								var parsedProps = JSON.parse(obj.properties);
								if(parsedProps.hasOwnProperty('texte')) { newFeature.texte = parsedProps.texte; }
								if(parsedProps.hasOwnProperty('rotation')) { newFeature.angle = Util.toRadians(parsedProps.rotation); }
							}
							
                            Util.transform(newFeature.getGeometry(), 'EPSG:4326', 'LMPROJ');
                            lay.getSource().addFeature(newFeature);
                        }
                });
            }
            }).error(function() {
                console.log("erreur chargement json");
            });
        });
    },
    
	createStyleFunc : function(layer) { 
		var self = this;
		var styleFunc;
		
		var props = JSON.parse(layer.style);
		
		 switch(layer.geomtype){
            case "Label": 
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    var divFactor = Math.pow(2, self.config.map.zmax - zoomLevel);

                    var txt = props.textTransformation === "toUpper" ? feat.texte.toUpperCase() : feat.texte; 
                    var lignes = txt.split('#');
                    var styles = [];
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {                       
                        $(lignes).each(function(key, value) { 
                            if (key==0) {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize/divFactor +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) }),
                                        rotation: feat.angle
                                    })
                                }));
                            } else {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize/divFactor +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) }),
                                        rotation: feat.angle
                                    }),
                                    geometry: function(feature) {
                                            // on crée un point d'ancrage décalé de x pixels (dans la config) pour les lignes suivantes
                                            var coordinates = feature.getGeometry().getCoordinates();
                                            coordinates[1] = coordinates[1] - props.interligne *key;
                                            return new ol.geom.Point(coordinates);
                                        }
                                    }) 
                                );
                            }
                        });
                        if (lignes.length==1) { return styles[0]; } else { return styles; }
                    }
                    else return null;
                };
                break;
            case "Surface": 
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) { 
                    	var leStyle = new ol.style.Style();                   	
                    	if (props.fillColor !== undefined) { 
                    		leStyle.setFill(new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) })); 
                    	}

                    	return leStyle;
                    } 
                    else return null;
                };
                break;
            case "Picto":
                styleFunc = function(feat, reso) {
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    var divFactor = Math.pow(2, self.config.map.zmax - zoomLevel);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {
                        // on regarde quel type d'image on a
                        var imgStyle = null; 
                        switch (props.imgSrc) {
                            case 'cercle' :
                                imgStyle = new ol.style.Circle({
                                    radius : props.pointRadius/divFactor,
                                    fill : new ol.style.Fill ({color: Util.hexToRgba(props.fillColor, props.fillOpacity) })
                                });
                            break;
                            default :
                                imgStyle = new ol.style.Icon({
                                    src: '{{ app.request.basepath }}/' + props.imgSrc,
                                    scale: 1/divFactor
                                });
                        }
                        return new ol.style.Style ({
                            image: imgStyle
                        });
                    } 
                    else return null;
                };
                break;
            case "LineString":
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {
                        var found = props.zooms.indexOf(zoomLevel);
		                
		                if (found !== -1) {
				            var lineStyle = new ol.style.Style ({
				                stroke: new ol.style.Stroke ({ 
				                    color: Util.hexToRgba(props.strokeColor, props.strokeOpacity),
				                    width: props.strokeWidth[found]
				                })
				            });
				            if (props.strokeDashArray !== undefined) { lineStyle.getStroke().setLineDash(props.strokeDashArray[found]);}
				            if (props.strokeCap !== undefined) {lineStyle.getStroke().setLineCap(props.strokeCap);}
				            return lineStyle;
		    			}
        			}
        			else return null;
                }; 
                break;
            default:
                console.log("style: type de géométrie non géré");
        } 
        return styleFunc;	
	},
    
};

Carte.createMap();
Carte.initMap();

</script>

{% endblock %}
