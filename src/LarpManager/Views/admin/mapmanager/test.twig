{% extends "layout_fs.twig" %}

{% block title %}{{ geomap.nom }}{% endblock title %}
       
{% block style %}

	    <link rel="stylesheet" href="{{ app.request.basepath }}/ol/ol.css" />
	    <link rel="stylesheet" href="{{ app.request.basepath }}/css/carte.css" />
	
{% endblock %}

{% block content %}
<div class="clearfix">
	<form class="form-inline">
      	<label>Action &nbsp;</label>
      	<select id="action_select">
       		<option value="none" selected>-- Aucune --</option>
       		<option value="translate">Déplacer (labels, pictos)</option>
       		<option value="modifyLabel">Modifier labels</option>
       		<option value="modifyLabelRotation">Modifier angle labels</option>
       		<option value="modifyLine">Modifier tracés linéaires (caravane...)</option>
       		<option value="modifyPays">Modifier surface pays</option>
       		<option value="modifyRegions">Modifier surface régions</option>
       		<option value="modifyFiefs">Modifier surface fiefs</option>
       		<option value="modifySea">Modifier zone maritime</option>
       		<option value="addVille">Ajouter pictos ville</option>
       		<option value="addCapitale">Ajouter pictos capitale</option>
       		<option value="addExplo">Ajouter pictos exploration</option>
       		<option value="addLabelFief">Ajouter un label fief</option>
       		<option value="addLabelVille">Ajouter un label ville</option>
       		<option value="addLabelCapitale">Ajouter un label capitale</option>
       		<option value="addLabelPoi">Ajouter un label POI</option>
       		<option value="addLabelRiviere">Ajouter un label rivière</option>
       		<option value="addLabelPasse">Ajouter un label passe, sente, gué...</option>
       		<option value="addLabelSea">Ajouter un label maritime</option>
       		<option value="addCaravane">Ajouter route commerciale</option>
       		<option value="addRiviere">Ajouter un tracé de rivière</option>
       		<option value="addLimPays">Ajouter une frontière pays</option>
       		<option value="addLimFief">Ajouter une frontière fief</option>
       		<option value="addSea">Ajouter une zone maritime</option>
       		<option value="addLimSea">Ajouter une limite maritime</option>
      	</select>    	
    </form>
    
	<div class="mapbox">
		<div id="map"></div>
	</div> 		
</div>
{% endblock %}

{% block javascript %}

<script src="{{ app.request.basepath }}/ol/ol.js"></script>
<script src="{{ app.request.basepath }}/js/carte_util.js"></script>

<script>
var geomapId = {{ geomap.id }}; 
var configSrc = '/mapmanager/config/get';
var featuresSrc = '/mapmanager/features';



var Carte = {
    olMap: null,			// l'objet ol.Map qui décrit la carte
    maxResolution: null,	// initialisé dans createMap
    resolutions: null, 		// initialisé dans createMap ; tableau des résolutions de la map (<=> aux différents niveaux de zoom) 
    config: null,			// la config de la carte récupérée dans la bdd, base de construction de la carte ol.Map
    projection: null, 		// initialisé dans createMap; la projection spécifique "à plat" utilisée n'est pas standard et doit être définie pour openLayers
    currentInteractions: [],
    
    initMap: function(mapId) { 
    	var self = this;
    	
    	$.ajax({
            dataType: "json",
            url: configSrc + '/' + geomapId,
            success: function(data) {
            	self.config = data;
            	self.createMap();
            	self.loadBackgroundLayer();
            	self.loadVectorLayers(); 
            	//self.showCountriesColors(); 
            	//self.showFiefsColors();   
            	//self.showRegionsColors(); 
            	//self.showNewPyramide();
            	//self.showSpecial();
        	}
        }).error(function() {
            console.log("erreur de lecture de la config, impossible de générer la carte");
        });
    },

    createMap: function(){
        var self = this;
        
        var mapMaxX = 16384; // taille du background image
        var mapMaxY = 11264; // à rendre paramétrable par la suite si d'autrtes fonds image sont utilisés
        var mapCenter = [mapMaxX / 2, mapMaxY / 2];
        self.projection = new ol.proj.Projection({
            code: 'LMPROJ',
            units: 'pixels',
            extent: [0, 0, mapMaxX, mapMaxY]
        });

        self.maxResolution = mapMaxX / 256;    // 16384 / 256 = 64
        self.resolutions = [];
        for (var z = 0; z <= 6; z++) {
            self.resolutions[z] = self.maxResolution / Math.pow(2, z); 					// 64, 32, 16, 8, 4, 2, 1 (7 niveaux)
        }

        this.olMap = new ol.Map({
            target: 'map',
            view: new ol.View({
                projection: self.projection, 
                zoom: 3, 	// à rendre paramétrable?
                minZoom: {{ geomap.zmin }},
                maxZoom: {{ geomap.zmax }},
                center: mapCenter, 
                extent: self.projection.getExtent(),
                enableRotation: false
            })
        });
    },
    
    loadBackgroundLayer: function () {
	    var backgroundLayer = new ol.layer.Tile({
		    source: new ol.source.TileImage({
		        tileUrlFunction: function(tileCoord, pixelRatio, projection) { 
		            var z = tileCoord[0];
		            var x = tileCoord[1];
		            var y = -tileCoord[2] - 1;
		            return '{{ app.request.basepath }}/img/map_clean/' + z + '/' + x + '/' + y + '.png';
		        },
		        projection: this.projection,
		        tileGrid: new ol.tilegrid.TileGrid({
		            origin: ol.extent.getTopLeft(this.projection.getExtent()),
		            resolutions: this.resolutions,
		            tileSize: 256
		        }),
		    }),
		    extent: this.projection.getExtent()
        }); 
        this.olMap.addLayer(backgroundLayer);   
    },
    
    loadVectorLayers: function () {
    	var self = this;

    	// on crée une couche vecteur pour chaque layer dans la config 
        $(self.config.layers).each(function(key, confLayer){
            var lay = new ol.layer.Vector({
                name: confLayer.categ,
                source: new ol.source.Vector({ features: new ol.Collection([]) })
            });
            lay.setProperties({	'geomType': confLayer.geomtype,
            					'geomTranslate': confLayer.geomTranslate,
            					'geomModify': confLayer.geomModify,
            					'propsModify': confLayer.propsModify,
            					'terrModify': confLayer.terrModify });
            self.olMap.addLayer(lay);
                       
            // On crée le style par défaut pour les éléments de cette couche, tel que défini dans la config
            var styleFunc = self.createStyleFunc(confLayer);
            lay.setStyle(styleFunc);
                       
            // Enfin, on crée les features           
            $.ajax({
                dataType: "json",
                url: featuresSrc + '/get/' + confLayer.categ,
                success: function(data) { 
                    $(data).each(function(key, obj) { 
                        if (obj.geojson != null)
                        {	
                        	// on crée la feature avec sa géométrie
                            var parsedGeom = JSON.parse(obj.geojson);		
							var newFeature, geom;

                            switch (confLayer.geomtype) {
                                case "Surface": 
                                	geom = new ol.geom.Polygon(parsedGeom.coordinates);
                                    break;
                                case "Label":
                                case "Picto":
                                	geom = new ol.geom.Point(parsedGeom.coordinates);
                                    break;
                                case "LineString" :
                                	geom = new ol.geom.LineString(parsedGeom.coordinates);
                                    break;
                                default:
                                    console.log("type de geometrie non traité");
                                    break;
                            }
                            newFeature = new ol.Feature({ geometry: geom });
                            newFeature.bddId = obj.id;	
                            newFeature.categ = confLayer.categ;				
                            
                            // on récupère les propriétés spécifiques à l'objet (pour le style individuel notamment)
							if (obj.properties != null) {
								var parsedProps = JSON.parse(obj.properties);
								if(parsedProps.hasOwnProperty('texte')) { newFeature.texte = parsedProps.texte; }
								if(parsedProps.hasOwnProperty('rotation')) { newFeature.rotation = parsedProps.rotation; }
							}
							
							// on ajoute à la carte pour l'affichage
                            Util.transform(newFeature.getGeometry(), 'EPSG:4326', 'LMPROJ');
                            lay.getSource().addFeature(newFeature);
                        }
                });
            }
            }).error(function() {
                console.log("erreur chargement json");
            });
        });
    },
    
	createStyleFunc : function(layer) { 
		// A faire : gestion d'erreurs
		var self = this;
		var styleFunc;
		
		var props = JSON.parse(layer.style);
		
		 switch(layer.geomtype){
            case "Label": 
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    var divFactor = Math.pow(2, self.config.map.zmax - zoomLevel);

                    var txt = props.textTransformation === "toUpper" ? feat.texte.toUpperCase() : feat.texte; 
                    var lignes = txt.split('#');
                    var styles = [];
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {                       
                        $(lignes).each(function(key, value) { 
                            if (key==0) {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize/divFactor +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) }),
                                        rotation: Util.toRadians(feat.rotation)
                                    })
                                }));
                            } else {
                                styles.push(new ol.style.Style ({
                                    text: new ol.style.Text({ 
                                        font: props.fontWeight +' '+props.fontSize/divFactor +'px '+ props.fontFamily,
                                        text: value,
                                        stroke: new ol.style.Stroke ({ color: Util.hexToRgba(props.strokeColor, props.strokeOpacity), width: props.strokeWidth}),
                                        fill: new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) }),
                                        rotation: Util.toRadians(feat.rotation)
                                    }),
                                    geometry: function(feature) {
                                            // on crée un point d'ancrage décalé de x pixels (dans la config) pour les lignes suivantes
                                            var coordinates = feature.getGeometry().getCoordinates();
                                            coordinates[1] = coordinates[1] - props.interligne *key;
                                            return new ol.geom.Point(coordinates);
                                        }
                                    }) 
                                );
                            }
                        });
                        if (lignes.length==1) { return styles[0]; } else { return styles; }
                    }
                    else return null;
                };
                break;
            case "Surface": console.log("surface trouvée");
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) { 
                    	var leStyle = new ol.style.Style();                   	
                    	if (props.fillColor !== undefined) { 
                    		leStyle.setFill(new ol.style.Fill({ color: Util.hexToRgba(props.fillColor, props.fillOpacity) })); 
                    	}

                    	return leStyle;
                    } 
                    else return null;
                };
                break;
            case "Picto":
                styleFunc = function(feat, reso) {
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    var divFactor = Math.pow(2, self.config.map.zmax - zoomLevel);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {
                        // on regarde quel type d'image on a
                        var imgStyle = null; 
                        switch (props.imgSrc) {
                            case 'cercle' :
                                imgStyle = new ol.style.Circle({
                                    radius : props.pointRadius/divFactor,
                                    fill : new ol.style.Fill ({color: Util.hexToRgba(props.fillColor, props.fillOpacity) })
                                });
                            break;
                            default :
                                imgStyle = new ol.style.Icon({
                                    src: '{{ app.request.basepath }}/' + props.imgSrc,
                                    scale: 1/divFactor
                                });
                        }
                        return new ol.style.Style ({
                            image: imgStyle
                        });
                    } 
                    else return null;
                };
                break;
            case "LineString":
                styleFunc = function(feat, reso){
                    var zoomLevel = Math.log2(self.maxResolution / reso);
                    
                    if(zoomLevel>=layer.zmin && zoomLevel<=layer.zmax) {//console.log(props);
                        var found = props.zooms.indexOf(zoomLevel);
		                
		                if (found !== -1) {
				            var lineStyle = new ol.style.Style ({
				                stroke: new ol.style.Stroke ({ 
				                    color: Util.hexToRgba(props.strokeColor, props.strokeOpacity),
				                    width: props.strokeWidth[found]
				                })
				            });
				            if (props.strokeDashArray !== undefined) { lineStyle.getStroke().setLineDash(props.strokeDashArray[found]);}
				            if (props.strokeCap !== undefined) {lineStyle.getStroke().setLineCap(props.strokeCap);}
				            return lineStyle;
		    			}
        			}
        			else return null;
                }; 
                break;
            default:
                console.log("style: type de géométrie non géré");
        } 
        return styleFunc;	
	},
    
    removeAllInteractions: function() { 
    	if (this.currentInteractions.length > 0) {
	    	while(this.currentInteractions.length > 0) {
	    		this.olMap.removeInteraction(this.currentInteractions.pop());
	    	}
    	}	
    },
       
    initTranslateInteraction : function () { 
        var self = this;
        var translate = new ol.interaction.Translate({ 
                layers: function(layer) {	                
            		if (layer.get('geomTranslate')!== undefined) {
            			return layer.get('geomTranslate');
            		} else return false;
            	},
                hitTolerance: 5
        });
        self.olMap.addInteraction(translate);
        self.currentInteractions.push(translate);
        
        translate.on('translateend', function (e) { 
            var newGeom = e.features.getArray()[0].getGeometry().clone();
            Util.transform(newGeom, 'LMPROJ', 'EPSG:4326');
            var convert = new ol.format.GeoJSON;
            var geojson = convert.writeGeometry(newGeom);
            
			var bddId = e.features.getArray()[0].bddId;
			var categ = e.features.getArray()[0].categ;
            
            $.ajax({
                type: "POST",
                dataType: 'json',
                url: featuresSrc + '/update',
                data: {geom: geojson, id: bddId, categ: categ},
                success: function(data) {
                	console.log(data);
                    //alert("la geographie a été enregistrée");
                }
            }).error(function() {
                alert("désolé, une erreur est survenue");
            });
        });       
    },
            
    initModifyLabelInteraction: function() {
    	var self = this;
    	
    	var select = new ol.interaction.Select({
    		layers: function(layer) { 
        		if (layer.get('propsModify')!== undefined && layer.get('geomType')=='Label') { 
        			return layer.get('propsModify');  
        		} else return false;
        	}
        	// A FAIRE : empêcher la sélection multiple
    	});
    	self.olMap.addInteraction(select);
    	self.currentInteractions.push(select);
    	
    	select.on('select', function(e) { // l'event est appelé au moment de la sélection et de la déselection 
    		// au moment de la sélection on affiche un dialogue pour saisir le nouveau label
    		if (e.selected.length > 0) { 
				var reponse = prompt("Utilisez # pour un retour à la ligne", e.selected[0].texte);

				if (reponse != null && reponse != '') { 
					var props = JSON.stringify({texte: reponse, rotation: e.selected[0].rotation}); 
					$.ajax({
		                type: "POST",
		                dataType: 'json',
 		                url: featuresSrc + "/update",
		                data: {properties: props, id: e.selected[0].bddId, categ: e.selected[0].categ},
		                success: function(data) {
		                	e.selected[0].texte = reponse;
		                	console.log(data);
		                    //alert("la geographie a été enregistrée");
		                }
		            }).error(function() {
		                alert("désolé, une erreur est survenue");
		            });
				}
			}
			
			// au moment de las déselection, on force le recalcul du style de la feature modifiée
			if (e.deselected.length > 0) {
				e.deselected[0].changed();
			}

    	});
    },
    
    initModifyLabelRotationInteraction: function() {
    	var self = this;
    	
    	var select = new ol.interaction.Select({
    		layers: function(layer) { 
        		if (layer.get('propsModify')!== undefined && layer.get('geomType')=='Label') { 
        			return layer.get('propsModify');  
        		} else return false;
        	}
        	// A FAIRE : empêcher la sélection multiple
    	});
    	self.olMap.addInteraction(select);
    	self.currentInteractions.push(select);
    	
    	select.on('select', function(e) { // l'event est appelé au moment de la sélection et de la déselection 
    		// au moment de la sélection on affiche un dialogue pour saisir le nouveau label
    		if (e.selected.length > 0) { 
				var reponse = prompt("angle en degrés", e.selected[0].rotation);
				if (reponse != null && reponse != '') { 
					var props = JSON.stringify({texte: e.selected[0].texte, rotation: reponse}); 
					$.ajax({
		                type: "POST",
		                dataType: 'json',
 		                url: featuresSrc + "/update",
		                data: {properties: props, id: e.selected[0].bddId, categ: e.selected[0].categ},
		                success: function(data) {
		                	e.selected[0].rotation = reponse;
		                	console.log(data);
		                    //alert("la geographie a été enregistrée");
		                }
		            }).error(function() {
		                alert("désolé, une erreur est survenue");
		            });
				}
			}
			
			// au moment de las déselection, on force le recalcul du style de la feature modifiée
			if (e.deselected.length > 0) {
				e.deselected[0].changed();
			}

    	});
    },
    
    initModifyInteraction: function(geomType, categ) {
        var self = this;
        var featureId, featureRevision;
        
		// Avant de pouvoir modify une feature il faut la sélectionner 
		var select = new ol.interaction.Select({
    		layers: function(layer) { 
        		if (layer.get('geomModify')!== undefined && (layer.get('geomType')===geomType)) { 
        			if (geomType==='Polygon') { // pour les polygones on ne peutt modifier qu'une categ à la fois, puor éviter les pb de sélection de feature superposées
        				if (layer.get('name') !== categ) {
        					return false;
    					}
        			}
        			return layer.get('geomModify');  
        		} else return false;
        	}
    	});
    	self.olMap.addInteraction(select);
    	self.currentInteractions.push(select);
    	
        var modify = new ol.interaction.Modify({
            features: select.getFeatures(),
            deleteCondition: function(event) {
            return ol.events.condition.shiftKeyOnly(event) &&
                ol.events.condition.singleClick(event);
            }
        });
        self.olMap.addInteraction(modify);
    	self.currentInteractions.push(modify);
    	
        select.on('select', function (e) {  	
        	if (e.deselected.length > 0) {
        		var newGeom = e.deselected[0].getGeometry().clone();
		        Util.transform(newGeom, 'LMPROJ', 'EPSG:4326');
		        var convert = new ol.format.GeoJSON;
		        var geojson = convert.writeGeometry(newGeom);
		        /*
		        if (e.deselected[0].categ ==='fief') { // les territoires sont formatés un peu différemment pour l'instant (tant que la page /world est utilisée)
		        	geojson = '{"type":"Feature","properties":{},"geometry":' + geojson + '}';
	        	}
*/
        		$.ajax({
	                type: "POST",
	                dataType: 'json',
	                url: featuresSrc + "/update",
	                data: {id: e.deselected[0].bddId, categ: e.deselected[0].categ, geom: geojson},
	                success: function(data) {
	                	console.log(data);
	                    //alert("la geographie a été enregistrée");
	                }
	            }).error(function(err) {
	                console.log(err); //alert("désolé, une erreur est survenue");
	            });
        	}
        });
    },
    
    initDrawInteraction : function(geomType, categ) {
    	var destinationLayer = null;
		this.olMap.getLayers().forEach( function(elem, index, tab) {
			if(elem.getProperties()['name']===categ) {
			destinationLayer = elem; } });
  	
        var drawInt = new ol.interaction.Draw({ 
                source: destinationLayer.getSource(), // où seront placées les features créées
                type: geomType
        });  
        this.olMap.addInteraction(drawInt);
        this.currentInteractions.push(drawInt);
        
        drawInt.setProperties({'categ' : categ});
        
        drawInt.on('drawend', function(e) {
            var newGeom = e.feature.getGeometry().clone();
            Util.transform(newGeom, 'LMPROJ', 'EPSG:4326');
            var convert = new ol.format.GeoJSON;
            var geojson = convert.writeGeometry(newGeom);
            	
			const words = categ.split('_');
			if (words[0] === 'label') {
				var reponse = prompt("Saisissez le texte à afficher : ");
				e.feature.texte = reponse;	
				e.feature.rotation = 0;
				var props = JSON.stringify({texte: reponse, rotation: 0}); 
				var datas = {categ: this.getProperties()['categ'], geom:geojson, properties:props};
			} else {
				var datas = {categ: this.getProperties()['categ'], geom:geojson}
			}
			e.feature.categ = categ;			

            $.ajax({
                type: "POST",
                dataType: 'json',
                url: featuresSrc + "/add",
                data: datas,
                success: function(data) {
                	e.feature.bddId = data.id;
                }
            }).error(function(err) {
                console.log(err); //alert("désolé, une erreur est survenue");
            });

        }, drawInt);
    },      
    
    
    showCountriesColors : function () { // affichage des pays en couleur transparente comme sur la prod, pour voir le rendu uniquement ---- juste pour mon dev ----
        var lay = new ol.layer.Vector({
            name: "surfpays",
            source: new ol.source.Vector({ features: new ol.Collection([]) })
        });
        lay.setProperties({	'geomType': 'Polygon' });
        //this.olMap.addLayer(lay);
        this.olMap.getLayers().insertAt(2,lay);
        
        $.ajax({
            dataType: "json",
            url: "{{ app.request.basepath }}/countries_multi.json",
            success: function(data) {
                $(data).each(function(key, obj) {
                    if (obj.geom != null)
                    {	
                        var parsedGeom = JSON.parse(obj.geom);
                        if(parsedGeom.geometry.type=="Polygon") {	
				            $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
				                Util.LonLatToLM(coords);
				            });
				            var newFeature = new ol.Feature({
				                geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
				            });

                        var style = new ol.style.Style({
                            fill: new ol.style.Fill({ color: Util.hexToRgba(obj.color, 0.6) })
                        });
                        newFeature.setStyle(style);
                        lay.getSource().addFeature(newFeature);

                        } else {
                        	
                        	$(parsedGeom.geometry.coordinates).each(function (tata, titi) {
                        		$(titi[0]).each(function (indx, coords) {
                        			Util.LonLatToLM(coords);
                        		});
                        	});
                        	
				            var newFeature = new ol.Feature({
				                geometry: new ol.geom.MultiPolygon(parsedGeom.geometry.coordinates)
				            });

                        var style = new ol.style.Style({
                            fill: new ol.style.Fill({ color: Util.hexToRgba(obj.color, 0.6) })
                        });
                        newFeature.setStyle(style);
                        lay.getSource().addFeature(newFeature);

                        }
                    }
            });
        }
        }).error(function() {
            console.log("erreur chargement json");
        });
    },

    showNewPyramide : function() {   
	    var lmproj = new ol.proj.Projection({
            code: 'LMPROJ',
            units: 'pixels',
            extent: [0, 0, 16384, 11264]
        });
		var resolutions = [];
        for (var z = 0; z <= 6; z++) {
            resolutions[z] = 64 / Math.pow(2, z); 					// 64, 32, 16, 8, 4, 2, 1 (7 niveaux)
        }
	    var newLayer = new ol.layer.Tile({
            source: new ol.source.TileImage({
                tileUrlFunction: function(tileCoord, pixelRatio, projection) { 
                    var z = tileCoord[0];
                    var x = tileCoord[1];
                    var y = -tileCoord[2] - 1;
                    return '{{ app.request.basepath }}/img/map_new/' + z + '/' + x + '/' + y + '.png';
                },
                projection: lmproj,
                tileGrid: new ol.tilegrid.TileGrid({
                    origin: ol.extent.getTopLeft(lmproj.getExtent()),
                    resolutions: resolutions,
                    tileSize: 256
                }),
            }),
            extent: lmproj.getExtent()
        }); 
        this.olMap.addLayer(newLayer);
	},
    
    
    showFiefsColors : function () { // affichage des fiefs en couleur transparente comme sur la prod, pour aide au tracé des frontières
        var lay = new ol.layer.Vector({
            name: "surffief",
            source: new ol.source.Vector({ features: new ol.Collection([]) })
        });
        lay.setProperties({	'geomType': "Polygon" });
        //this.olMap.addLayer(lay);
        this.olMap.getLayers().insertAt(2,lay);
        
        $.ajax({
            dataType: "json",
            url: "{{ app.request.basepath }}/fiefs.json",
            success: function(data) {
                $(data).each(function(key, obj) {
                    if (obj.geom != null)
                    {	
                        var parsedGeom = JSON.parse(obj.geom);		
                        $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
                            Util.LonLatToLM(coords);
                        });
                        var newFeature = new ol.Feature({
                            geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
                        });
                        if(obj.color!=null) {
                        var style = new ol.style.Style({
                            fill: new ol.style.Fill({ color: Util.hexToRgba(obj.color, 0.2) })
                        });
                        newFeature.setStyle(style);}
                        lay.getSource().addFeature(newFeature);
                    }
            });
        }
        }).error(function() {
            console.log("erreur chargement json");
        });
    },
    
    showRegionsColors : function () { // affichage des régions en couleur transparente comme sur la prod
        var lay = new ol.layer.Vector({
            name: "surfregion",
            source: new ol.source.Vector({ features: new ol.Collection([]) })
        });
        lay.setProperties({	'geomType': "Polygon" });
        //this.olMap.addLayer(lay);
        this.olMap.getLayers().insertAt(2,lay);
        
        $.ajax({
            dataType: "json",
            url: "{{ app.request.basepath }}/regions.json",
            success: function(data) {
                $(data).each(function(key, obj) {
                    if (obj.geom != null)
                    {	
                        var parsedGeom = JSON.parse(obj.geom);		
                        $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
                            Util.LonLatToLM(coords);
                        });
                        var newFeature = new ol.Feature({
                            geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
                        });
                        if(obj.color!=null) {
                        var style = new ol.style.Style({
                            fill: new ol.style.Fill({ color: Util.hexToRgba(obj.color, 0.5) })
                        });
                        newFeature.setStyle(style);}
                        lay.getSource().addFeature(newFeature);
                    }
            });
        }
        }).error(function() {
            console.log("erreur chargement json");
        });
    },
    
    showSpecial : function () { // affichage d'une géométrie
        var lay = new ol.layer.Vector({
            name: "surfspecial",
            source: new ol.source.Vector({ features: new ol.Collection([]) })
        });
        lay.setProperties({	'geomType': "Polygon" });
        //this.olMap.addLayer(lay);
        this.olMap.getLayers().insertAt(2,lay);
        
        var parsedGeom = {
        	"type":"Feature",
        	"properties":{},
        	"geometry":{
        		"type":"Polygon",
        		"coordinates":[[[97,-63.625],[97.5,-64.4375],[99.1875,-64.1875],[99.8125,-64.5],[99,-65.5],[98.75,-66.5625],[93.875,-69.875],[97.5,-69.875],[96.125,-71],[93.25,-72.3125],[91.5625,-72.5],[90.5,-72.875],[88.875,-75.5],[84.5,-75.625],[83.6875,-76.25],[82.8125,-76.3125],[83.75,-79.125],[81.9375,-77.1875],[80.5625,-77.8125],[79.5625,-78.75],[78.0625,-78.5625],[76,-78.75],[74.4375,-78.1875],[73.0625,-78.0625],[72.8125,-76.9375],[73.5625,-76.625],[74,-75.5],[77.125,-74.625],[77.125,-73.6875],[81.1875,-72.5625],[82.75,-72.5],[83.4375,-70.8125],[84.875,-70.6875],[86.25,-69.9375],[86.9375,-69.1875],[88.6875,-68.9375],[88.3125,-67.5],[89.125,-67.4375],[89.9375,-68],[91.8125,-67.75],[91.3125,-67],[92.75,-66.5625],[92.75,-65.25],[93.875,-65.4375],[94.8125,-65.4375],[95.375,-64.625],[97,-63.625]]]
    		}
		};
        $(parsedGeom.geometry.coordinates[0]).each(function(toto, coords) {
            Util.LonLatToLM(coords);
        });
        var newFeature = new ol.Feature({
            geometry: new ol.geom.Polygon(parsedGeom.geometry.coordinates)
        });
        var style = new ol.style.Style({
	        fill: new ol.style.Fill({ color: Util.hexToRgba("#2548AC", 0.8) })
		});
        newFeature.setStyle(style);
        lay.getSource().addFeature(newFeature);  
    },
    
    initModifyPourProdInteraction: function(geomType, categ) { 
        var self = this;
        var featureId, featureRevision;
        
		// Avant de pouvoir modify une feature il faut la sélectionner 
		var select = new ol.interaction.Select({
    		layers: function(layer) { 
    			if (layer.get('name') === categ) { console.log("trouvé");
					return true;
				} 	
        	}
    	});
    	self.olMap.addInteraction(select);
    	self.currentInteractions.push(select);
    	
        var modify = new ol.interaction.Modify({
            features: select.getFeatures(),
            deleteCondition: function(event) {
            return ol.events.condition.shiftKeyOnly(event) &&
                ol.events.condition.singleClick(event);
            }
        });
        self.olMap.addInteraction(modify);
    	self.currentInteractions.push(modify);
    	
        select.on('select', function (e) {  	
        	if (e.deselected.length > 0) {
        		var newGeom = e.deselected[0].getGeometry().clone();
		        Util.transform(newGeom, 'LMPROJ', 'EPSG:4326');
		        var convert = new ol.format.GeoJSON;
		        var geojson = convert.writeGeometry(newGeom);
		        
		        console.log(geojson);    
        	}
        });
    },
};

Carte.initMap();
//Carte.showCountriesColors(true); // pour afficher la surcouche des pays en couleur
//Carte.showNewPyramide();


var actionSelect = document.getElementById('action_select');

actionSelect.onchange = function() {	
	Carte.removeAllInteractions();
	
	switch(actionSelect.value) {
		case "translate" :
			Carte.initTranslateInteraction(); break;
		case "modifyLabel" :
			Carte.initModifyLabelInteraction(); break;	
		case "modifyLabelRotation" :
			Carte.initModifyLabelRotationInteraction(); break;	
		case "modifyLine" : 
			Carte.initModifyInteraction('LineString','all'); break;
		case "modifyPays" : 
			Carte.initModifyPourProdInteraction('Polygon','surfpays'); break;
		case "modifyFiefs" : 
			Carte.initModifyPourProdInteraction('Polygon','surffief'); break;
		case "modifyRegions" : 
			Carte.initModifyPourProdInteraction('Polygon','surfregion'); break;
		case "modifySea" :
			Carte.initModifyInteraction('Polygon','zonedeau'); break;
		case "addVille" :
			Carte.initDrawInteraction('Point','ville'); break;
		case "addCapitale" :
			Carte.initDrawInteraction('Point','capitale'); break;
		case "addExplo" :
			Carte.initDrawInteraction('Point','exploration'); break;
		case "addLabelPoi" : 
			Carte.initDrawInteraction('Point','label_poi'); break;
		case "addLabelFief" :
			Carte.initDrawInteraction('Point','label_fief'); break;
		case "addLabelVille" :
			Carte.initDrawInteraction('Point','label_ville'); break;
		case "addLabelCapitale" :
			Carte.initDrawInteraction('Point','label_capitale'); break;
		case "addLabelRiviere" :
			Carte.initDrawInteraction('Point','label_riviere'); break;
		case "addLabelPasse" :
			Carte.initDrawInteraction('Point','label_passe'); break;
		case "addLabelSea":
			Carte.initDrawInteraction('Point','label_sea'); break;
		case "addCaravane" :
			Carte.initDrawInteraction('LineString','caravane'); break;
		case "addRiviere" :
			Carte.initDrawInteraction('LineString','riviere'); break;
		case "addLimPays" :
			Carte.initDrawInteraction('LineString','lim_pays'); break;
		case "addLimFief" :
			Carte.initDrawInteraction('LineString','lim_fief'); break;
		case "addSea" :
			Carte.initDrawInteraction('Polygon','zonedeau'); break;
		case "addLimSea" :
			Carte.initDrawInteraction('LineString','lim_sea'); break;
	}
};
</script>

{% endblock %}
